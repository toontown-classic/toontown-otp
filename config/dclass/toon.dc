keyword required;
keyword broadcast;
keyword ram;
keyword db;
keyword p2p;
keyword clsend;
keyword ownsend;
keyword airecv;

// The most fundamental class
dclass DistributedObject {
};

// The TimeManager should be created before all other objects, because
// network timestamps can't be accurately decoded until the
// TimeManager has been created.
dclass TimeManager : DistributedObject {
  requestServerTime(uint8 context) airecv clsend;
  serverTime(uint8 context, int16 timestamp, uint32 timeOfDay);

  // This message is sent from the client to the AI when it disconnects
  // cleanly.  It is a bit of a hack to put it here in the TimeManager
  // (because what does the TimeManager have to do with that?) but we
  // can't put it on the toon because it is a message to the AI, and
  // this is a convenient place to put it instead.
  setDisconnectReason(uint8 disconnectCode) airecv clsend;
};

dclass DistributedNode : DistributedObject {
  setParent(uint8 token) broadcast ram ownsend;

  setX(int16 / 10) broadcast ram ownsend;
  setY(int16 / 10) broadcast ram ownsend;
  // We need more resolution in Z so the shadow does not appear
  // below the ground due to roundoff error. We are sacrificing
  // range for accuracy
  setZ(int16 / 100) broadcast ram ownsend;
  setH(int16 / 10) broadcast ram ownsend;
  setP(int16 / 10) broadcast ram ownsend;
  setR(int16 / 10) broadcast ram ownsend;

  setPos : setX, setY, setZ;
  setHpr : setH, setP, setR;
  setPosHpr : setX, setY, setZ, setH, setP, setR;
  setXY : setX, setY;
  setXZ : setX, setZ;
  setXYH : setX, setY, setH;
  setXYZH : setX, setY, setZ, setH;
};

dclass DistributedSmoothNode : DistributedNode {
  // Component set pos and hpr functions.
  setComponentX(int16 / 10) broadcast ram ownsend;
  setComponentY(int16 / 10) broadcast ram ownsend;
  setComponentZ(int16 / 100) broadcast ram ownsend;
  setComponentH(int16 / 10) broadcast ram ownsend;
  setComponentP(int16 / 10) broadcast ram ownsend;
  setComponentR(int16 / 10) broadcast ram ownsend;
  setComponentT(int16 timestamp) broadcast ram ownsend;

  // Composite set pos and hpr functions.  These map to combinations
  // of one or more of the above components.  They all include
  // setComponentT(), which must be called last.
  setSmStop : setComponentT;
  setSmH : setComponentH, setComponentT;
  setSmXY : setComponentX, setComponentY, setComponentT;
  setSmXZ : setComponentX, setComponentZ, setComponentT;
  setSmPos : setComponentX, setComponentY, setComponentZ, setComponentT;
  setSmHpr : setComponentH, setComponentP, setComponentR, setComponentT;
  setSmXYH : setComponentX, setComponentY, setComponentH, setComponentT;
  setSmXYZH : setComponentX, setComponentY, setComponentZ, setComponentH, setComponentT;
  setSmPosHpr : setComponentX, setComponentY, setComponentZ, setComponentH, setComponentP, setComponentR, setComponentT;

  // I don't need any parameters, but for some reason leaving the
  // parameter list empty on this one causes a server crash.
  clearSmoothing(int8 bogus) broadcast ownsend;
};

dclass DistributedToon : DistributedSmoothNode {
  setName(string) required broadcast ram db;
  setDNAString(blob) required broadcast ram db;
  setMaxBankMoney(int16 = 1000) required broadcast ram db;
  setBankMoney(int16 = 0) required broadcast ram db;
  setMaxMoney(int16 = 40) required broadcast ram db;
  setMoney(int16 = 0) required broadcast ram db;
  setMaxHp(int16 = 15) required broadcast db;
  setHp(int16 = 15) required broadcast db;
  setExperience(blob = { 0 * 14 }) required p2p db;
  setMaxCarry(uint8 = 20) required p2p db;
  // all I need is a single bit for each track, but uint8array is the
  // smallest and it crashes
  setTrackAccess(uint16array = {0,0,0,0,1,1,0}) required broadcast db;
  // Progress training a track. -1 trackId means no track, progress is a bit array
  setTrackProgress(int8 trackId = -1, uint32 progress = 0) required p2p db;
  // a 42 byte string of uint8s. We give some props for starters.
  setInventory(blob = { 0 * 6,       // Heal
                        0 * 6,       // Trap
                        0 * 6,       // Lure
                        0 * 6,       // Sound
                        1, 0 * 5,    // Throw
                        1, 0 * 5,    // Squirt
                        0 * 6        // Drop
                        }) required p2p db;

  setFriendsList(uint32uint8array = {}) required p2p db;

  setDefaultShard(uint32 = 200000000) required p2p db;
  setDefaultZone(uint16 = 2000) required p2p db;
  setShtickerBook(blob = {}) required p2p db;
  setZonesVisited(uint16array = { 2000 }) required p2p db;
  setHoodsVisited(uint16array = { 2000 }) required p2p db;
  setInterface(blob = {}) required p2p db;
  setAccountName(string = "unknown") required p2p db;
  setLastHood(uint16 = 2000) required p2p db;
  setTutorialAck(uint8 = 0) required p2p db;

  setMaxClothes(uint32 = 10) required p2p db;
  setClothesTopsList(uint8array clothesTopsList = {}) required p2p db;
  setClothesBottomsList(uint8array clothesBottomsList = {}) required p2p db;

  // The AI uses this to tell the toon how much earned experience he
  // has accumulated so far within a particular battle.  This is
  // important to allow the client to gray out gag buttons when the
  // toon exceeds his experience cap for the battle.
  setEarnedExperience(uint16array earnedExp) p2p;

  // toon final X position wrt tunnel, tunnel pos/heading
  setTunnelIn(int16 timestamp,
              int16/10 endX,
              int16/10 x, int16/10 y, int16/100 z,
              int32/100 h) ownsend broadcast;
  // toon starting position wrt tunnel, tunnel pos/heading
  setTunnelOut(int16 timestamp,
               int16/10 startX, int16/10 startY,
               int16/10 x, int16/10 y, int16/100 z,
               int32/100 h) ownsend broadcast;

  setAnimState(blob, int16 / 1000, int16 timestamp) broadcast ram ownsend;

  setChat(string chat, uint8 chatFlags) broadcast ownsend;

  setEmoteState(uint32, int16 / 1000, int16 timestamp) broadcast ram ownsend;
  setEmoteAccess(uint8array bits = {1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}) required p2p db;

  // placehoder int16 parameter to avoid server crash
  playSplashEffect(int16/10 x, int16/10 y, int16/10 z) broadcast ownsend;

  // These whisper messages are sent from another client.  For now, we
  // have to put the fromId in the message, but eventually we need to
  // have a way to validate these.
  setWhisperFrom(uint32 fromId, string) p2p clsend;
  setWhisperQTFrom(uint32 fromId, uint8array) p2p clsend;
  setWhisperQTQuestFrom(uint32 fromId, uint32array) p2p clsend;
  setWhisperQTCustomFrom(uint32 fromId, uint16 messageIndex) airecv clsend;
  setWhisperIgnored(uint32 fromId) p2p clsend;

  // This is an onscreen message sent by the system.
  setSystemMessage(uint32 aboutId, string) p2p;

  setQT(uint8array) broadcast ownsend;
  setQTQuest(uint32array) broadcast ownsend;
  setQTCustom(uint16 messageIndex) broadcast ownsend;
  setCommonChatFlags(uint8) broadcast p2p ram;

  // The trophy score is not a permanent property of the toon, so it
  // does not get saved in the database.  It is instead set by the AI,
  // and it varies from shard to shard.
  setTrophyScore(uint16 score) broadcast p2p ram;

  // This message is sent by the AI to notify the client when friends
  // are added or removed without the client's participation, if the
  // client happens to be logged in.  It also might be sent directly
  // from the friend (or former friend).
  // TODO: this is still clsend but should not be to be secure
  friendsNotify(int32 avId, int8 status) p2p clsend;

  // List of safe zones you can teleport to
  setTeleportAccess(uint32array = {}) required p2p db;

  // TODO: check these clsends closely for security later
  battleSOS(uint32 requesterID) p2p clsend;
  teleportQuery(uint32 requesterId) p2p clsend;
  teleportResponse(uint32 avId, int8 available, uint32 shardId,
                   uint16 hoodId, uint16 zoneId) p2p clsend;
  teleportGiveup(uint32 avId) p2p clsend;
  teleportGreeting(uint32 avId) broadcast ownsend;

  setCogStatus(uint32array = {1 * 32}) required p2p db;
  setCogCount(uint32array = {0 * 32}) required p2p db;

  setCogRadar(uint8array = {0 * 4}) required p2p db;
  setBuildingRadar(uint8array = {0 * 4}) required p2p db;

  setFishes(uint32array = {}) required p2p db;
  setHouseId(uint32 id = 0) required p2p db;
  setQuests(uint32array = {}) required broadcast db;
  setQuestHistory(uint16array = {}) required p2p db;
  setRewardHistory(uint8 tier = 0, uint16array = {}) required p2p db;
  setQuestCarryLimit(uint8 = 1) required p2p db;

  setCheesyEffect(int16 effect = 0, uint16 hoodId = 0, uint32 expireTime = 0) required broadcast db;
  setPosIndex(uint8 index = 0) required p2p db;
  suggestResync(uint32 avId) p2p clsend;

  // these fields are for the Servers .. client should never see these ??
  // the index
  OwningAccount(uint32 avId = 0);
  // the string the person want to be there av's name
  WishName(string = "");
  // CLOSED,OPEN,USED,.. The state of the name review process
  WishNameState(string = "");
};

dclass Account {
// RHH
// This is for internal server usa only...

  // the 6 avatars a person has
  ACCOUNT_AV_SET( uint32array );
  // some old records have this no longer tracked
  BIRTH_DATE( string );
  // this is the swid... or external name..
  BLAST_NAME( string="" );
  // date of creation in local machine time
  CREATED(string="" );
  // the name for the account  ( no longer tracked )
  FIRST_NAME(string="" );
  // the last time this person account connected to game
  LAST_LOGIN(string="" );
  // No Longer Tracked
  LAST_NAME( string="" );
  // total time this account has been loged in ..
  PLAYED_MINUTES( string="" );
  // total time this account has been loged in this period
  PLAYED_MINUTES_PERIOD( string="" );
  //PASSWD( string );
  // the 6 houses a person has
  HOUSE_ID_SET( uint32array );
  ESTATE_ID( uint32 );
};


dclass DistributedCCharBase : DistributedObject {
  // Make jibber-jabber
  setChat(uint32 category, uint32 msg, uint32 avId) broadcast;
  // Make walk
  setWalk(string srcNode, string destNode,
          int16 timestamp) required broadcast ram;
  // These let the server know when toons show up and leave
  avatarEnter() p2p clsend;
  avatarExit() p2p clsend;
  // These let the server know when a nearby toon talks
  setNearbyAvatarChat(string msg) p2p clsend;
  setNearbyAvatarQT(uint8array qtList) p2p clsend;
  setNearbyAvatarQTQuest(uint32array qtList) p2p clsend;
};

dclass DistributedMickey : DistributedCCharBase {
};
dclass DistributedMinnie : DistributedCCharBase {
};
dclass DistributedGoofy : DistributedCCharBase {
};
dclass DistributedDonald : DistributedCCharBase {
};
dclass DistributedPluto : DistributedCCharBase {
};

dclass DistributedTrolley : DistributedObject {
  // How the server tells the client what state to enter into
  setState(string, int16 timestamp) broadcast ram;
  // How the server tells the client to fill the slots
  fillSlot0(uint32 avId,
            int16 x/10, int16 y/10, int16 z/10,   // initial xyz
            int16 h/10, int16 p/10, int16 r/10,   // initial hpr
            int16 timestamp) broadcast ram;       // time of boarding
  fillSlot1(uint32 avId,
            int16 x/10, int16 y/10, int16 z/10,   // initial xyz
            int16 h/10, int16 p/10, int16 r/10,   // initial hpr
            int16 timestamp) broadcast ram;       // time of boarding
  fillSlot2(uint32 avId,
            int16 x/10, int16 y/10, int16 z/10,   // initial xyz
            int16 h/10, int16 p/10, int16 r/10,   // initial hpr
            int16 timestamp) broadcast ram;       // time of boarding
  fillSlot3(uint32 avId,
            int16 x/10, int16 y/10, int16 z/10,   // initial xyz
            int16 h/10, int16 p/10, int16 r/10,   // initial hpr
            int16 timestamp) broadcast ram;       // time of boarding

  // How the server tells the client to empty the slots
  emptySlot0(uint32 avId, int16 timestamp) broadcast ram;
  emptySlot1(uint32 avId, int16 timestamp) broadcast ram;
  emptySlot2(uint32 avId, int16 timestamp) broadcast ram;
  emptySlot3(uint32 avId, int16 timestamp) broadcast ram;

  // ****
  // How the client requests permission to board
  requestBoard(int16 x/10, int16 y/10, int16 z/10,   // initial xyz
               int16 h/10, int16 p/10, int16 r/10    // initial hpr
               ) p2p clsend;

  // How the server rejects permission to board
  rejectBoard(uint32 avId) p2p;

  // ****
  // How the client requests permission to exit
  requestExit() p2p clsend;

  // How the server puts the clients into a minigame
  setMinigameZone(uint16 zoneId, uint16 minigameId) p2p;
};


dclass DistributedSuitPlanner : DistributedObject {
  // tell the client-side suit planner which zone it exists in
  setZoneId(uint16 zoneId) required broadcast ram;
  suitListQuery() p2p clsend;
  suitListResponse(uint8array suitList) p2p;
  buildingListQuery() p2p clsend;
  buildingListResponse(uint8array buildingList) p2p;
};

dclass DistributedSuit : DistributedObject {

  // ****
  requestBattle(int16 x / 10, int16 y / 10, int16 z / 10,
                int16 h / 10, int16 p / 10, int16 r / 10) p2p clsend;
  denyBattle() p2p;

  // set the dna of this suit before it is generated
  //
  setDNAString(blob dna) required broadcast ram;

  // notify the client side suit that the server side suit
  // has changed its level
  //
  setLevelDist(int16 level) required broadcast ram;

  // specify the distributed object id of the suit planner that
  // this suit will use for getting access to path information
  // for the street this suit exists in
  //
  setSPDoId(uint32 spDoId) required broadcast ram;

  // We don't send chat messages literally through the net for Suits.
  // Instead, we use setBrushOff to send brush-off messages by index
  // number, or the battle movie system to manage taunts by index
  // number.
  //  setChat(string chat, int16 chatFlags) broadcast;
  setBrushOff(int16 index) broadcast;

  // Defines the path along the street the suit will walk.  We only
  // transmit the start and end points; the complete path is inferred
  // from these.
  setPathEndpoints(uint16 start, uint16 end) required broadcast ram;

  // Defines the current position of the suit along its path.  We only
  // get these updates every once and a while, and only to keep the
  // timestamp from going stale.
  setPathPosition(uint16 index, int16 timestamp) required broadcast ram;

  // Defines whether the suit is actively walking on the path.
  setPathState(int8 state) required broadcast ram;

  // This message is sent from the AI only when debug-suit-positions
  // is configured #t.  It is used to double-check that the client is
  // receiving sensible suit position reporting.
  debugSuitPosition(int16 elapsedTime / 10, int16 currentLeg,
                    int16 x / 10, int16 y / 10,
                    int16 timestamp) broadcast;
};

dclass DistributedBattleBase : DistributedObject {
  setPosition(int16 x / 10, int16 y / 10, int16 z / 10) required broadcast ram;
  setZoneId(uint32 zoneId) required broadcast ram;
  setInitialSuitPos(int16 x / 10, int16 y / 10, int16 z / 10) required broadcast ram;
  setMembers(uint32array, string, string, string, string, string,
             uint32array, string, string, string, string,
             int16 timestamp) required broadcast ram;

  adjust(int16 timestamp) broadcast;

  // calculated battle values from the server.
  setMovie(
           //   flag indicating an empty movie
           //   array of toon doIds
           //   array of suit doIds
           int8 active, uint32array toons, uint32array suits,

           //   index of attacking toon
           //   attack track
           //   attack level
           //   index of the target (or doId if it's an SOS)
           //   array of damages
           //   accuracy bonus for the attack
           //   damage bonus for the attack
           //   array of knockback bonuses
           //   bit-field indicating indices of suits that have died from this attack
           int8 id0, int8 tr0, int8 le0, int32 tg0, int16array hp0,
           int16 ac0, int16 hpb0, int16array kbb0, int8 died0,

           int8 id1, int8 tr1, int8 le1, int32 tg1, int16array hp1,
           int16 ac1, int16 hpb1, int16array kbb1, int8 died1,

           int8 id2, int8 tr2, int8 le2, int32 tg2, int16array hp2,
           int16 ac2, int16 hpb2, int16array kbb2, int8 died2,

           int8 id3, int8 tr3, int8 le3, int32 tg3, int16array hp3,
           int16 ac3, int16 hpb3, int16array kbb3, int8 died3,

           //   index of the attacking suit
           //   id of the suit's attack
           //   index of the target of the attack
           //   array of damages
           //   bit-field indicating indices of toons that have died from this attack
           //   flag indicating if this suit attacks before the toons this round
           int8 sid0, int8 at0, int8 stg0, int16array dm0, int8 sd0,
           int8 db0, int8 st0,

           int8 sid1, int8 at1, int8 stg1, int16array dm1, int8 sd1,
           int8 db1, int8 st1,

           int8 sid2, int8 at2, int8 stg2, int16array dm2, int8 sd2,
           int8 db2, int8 st2,

           int8 sid3, int8 at3, int8 stg3, int16array dm3, int8 sd3,
           int8 db3, int8 st3
           ) required broadcast ram;

  // similar to setMovie with the following values:
  //   array of doIds for attacking toons
  //   array of tracks
  //   array of levels
  //   array of doIds for targets
  setChosenToonAttacks(uint32array ids, int16array tracks, int16array levels,
                       int32array targets) broadcast ram;

  setBattleExperience(int32 id0, int16array origExp0, int16array earnedExp0,
                      int16array items0, int16array missedItems0,

                      int32 id1, int16array origExp1, int16array earnedExp1,
                      int16array items1, int16array missedItems1,

                      int32 id2, int16array origExp2, int16array earnedExp2,
                      int16array items2, int16array missedItems2,

                      int32 id3, int16array origExp3, int16array earnedExp3,
                      int16array items3, int16array missedItems3,

                      int16array deathList) required broadcast ram;

  // Used by DistributedBattleBldg only, but needs to happen before setState
  setBossBattle(uint8 value) required broadcast ram;
  setState(string state, int16 timestamp) required broadcast ram;

  // Messages to the server
  faceOffDone() p2p clsend;
  toonRequestJoin(int16 / 10, int16 / 10, int16 / 10) p2p clsend;
  toonRequestRun() p2p clsend;
  adjustDone() p2p clsend;
  timeout() p2p clsend;
  movieDone() p2p clsend;
  rewardDone() p2p clsend;
  joinDone(uint32 avId) p2p clsend;
  requestAttack(int8, int8, uint32) p2p clsend;
};

dclass DistributedBattle : DistributedBattleBase {
  denyLocalToonJoin() p2p;
};

dclass DistributedBattleBldg : DistributedBattleBase {
};

dclass DistributedBattleTutorial : DistributedBattle {
};

dclass DistributedBoat : DistributedObject {
  setState(string state, int16 timestamp) required broadcast ram;
};

dclass DistributedButterfly : DistributedObject {
  setArea(int16 playground, int16 area) required broadcast ram;
  setState(int8 stateIndex, uint8 curIndex, uint8 destIndex, uint16 time / 10, int16 timestamp) required broadcast ram;
  avatarEnter() p2p clsend;
};

dclass DistributedMMPiano : DistributedObject {
  // Messages from clients to AI
  requestSpeedUp() airecv clsend;
  requestChangeDirection() airecv clsend;

  // Messages from AI to clients
  setSpeed(int16 rpm / 1000, uint16 offset / 100, int16 timestamp) broadcast ram;
  playSpeedUp(uint32 avId) broadcast;
  playChangeDirection(uint32 avId) broadcast;
};

dclass DistributedDGFlower : DistributedObject {
  // Messages from clients to AI
  avatarEnter() p2p clsend;
  avatarExit() p2p clsend;

  // Messages from AI to clients
  setHeight(uint8 height / 10) broadcast ram;
};

dclass DistributedFishingSpot : DistributedObject {
  // Where is the fishing spot?
  setPosHpr(int16 x / 10, int16 y / 10, int16 z / 10,
            int16 h / 10, int16 p / 10, int16 r / 10) required broadcast ram;

  // The client requests use of the fishing spot:
  requestEnter() airecv clsend;

  // The client within the fishing spot is ready to leave:
  requestExit() airecv clsend;

  // Who's fishing?  0 == empty.
  setOccupied(uint32 avId) broadcast ram;

  // Go fish!
  doCast() airecv clsend;
  doAutoReel() airecv clsend;
  doReel(int16 speed / 1000, uint16 netTime / 1000, int16 netDistance / 100) airecv clsend;

  // Tell the client what speed he's aiming for on this particular fish.
  setTargetSpeed(int16 speed / 1000);

  // The fishing movie(s).
  setMovie(int8 mode, int16 code, int16 item, int16 speed / 1000) broadcast ram;
  // Ask the client to release a fish
  fishReleaseQuery(uint8 fish) airecv clsend;

  // The client tells the AI he's rleased a fish
  fishReleased(uint8 fish) airecv clsend;

};

dclass DistributedMinigame : DistributedObject {
  // NOTE: the avIds of the participants cannot
  //   be used until setGameReady() is called
  setParticipants(uint32array avIds) broadcast ram required;
  setTrolleyZone(uint16 zone) broadcast ram required;

  // this is for debugging difficulty levels
  setDifficultyOverrides(uint32 difficultyOverride,
                         uint32 trolleyZoneOverride) broadcast ram required;

  // Messages sent from client to AI
  setAvatarJoined() p2p clsend;
  setAvatarReady() p2p clsend;
  setAvatarExited() p2p clsend;

  // For debugging only... terminates a minigame.
  requestExit() p2p clsend;
  setGameReady() broadcast;
  setGameStart(int16 timestamp) broadcast;
  setGameExit() broadcast;
  setGameAbort() broadcast;
};

dclass DistributedMinigameTemplate : DistributedMinigame {
};

dclass DistributedRaceGame : DistributedMinigame {
  setTimerStartTime(int16 timestamp) broadcast;
  setAvatarChoice(uint8 choice) p2p clsend;
  setAvatarChose(uint32 avId) broadcast;
  setChancePositions(uint8array positions) broadcast;
  setServerChoices(int8array choices, uint8array positions, int8array rewards) broadcast;
};

dclass DistributedCannonGame : DistributedMinigame {
  setCannonPosition(int32 zRot / 100, uint32 angle / 100) p2p clsend;
  setCannonLit(int32 zRot / 100, uint32 angle / 100) p2p clsend;
  updateCannonPosition(uint32 avId, int32 zRot / 100,
                       uint32 angle / 100) broadcast;
  setCannonWillFire(uint32 avId, int32 fireTime/100,
                    int32 zRot / 100, uint32 angle / 100) broadcast;
  setToonWillLandInWater(int32 landTime/100) p2p clsend;
  announceToonWillLandInWater(uint32 avId, int32 landTime/100) broadcast;
};

dclass DistributedPatternGame : DistributedMinigame {
  reportPlayerReady() p2p clsend;
  setPattern(uint8array pattern) broadcast;
  reportPlayerPattern(uint8array pattern, uint16 totalTime / 1000) p2p clsend;
  setPlayerPatterns(uint8array pattern1, uint8array pattern2,
                    uint8array pattern3, uint8array pattern4,
                    uint32 fastestAvId ) broadcast;
  // these two are sent as the buttons are pressed, so that
  // you can see what the remote toons are doing
  reportButtonPress(uint8 index, uint8 wrong) p2p clsend;
  remoteButtonPressed(uint32 avId, uint8 index, uint8 wrong) broadcast;
};

dclass DistributedRingGame : DistributedMinigame {
  // common time base for all players
  setTimeBase(int16 timestamp) broadcast ram required;
  // Random selection of ring colors
  setColorIndices(int8 a, int8 b, int8 c, int8 d) broadcast ram required;

  // sent by client; success == 0 means localtoon missed its ring
  setToonGotRing(uint8 success) p2p clsend;
  // sent to clients after all results are in
  // bit==0 means the toon got their ring; bitfield==0 means overall success
  // not used in single-player
  setRingGroupResults(uint8 bitfield) broadcast;
};

dclass DistributedTagGame : DistributedMinigame {
  tag(uint32 taggedAvId) p2p clsend;
  setIt(uint32 itAvId) broadcast;
  setTreasureScore(uint16array scores) broadcast;
};

dclass DistributedMazeGame : DistributedMinigame {
  claimTreasure(uint32 treasureNum) p2p clsend;
  setTreasureGrabbed(uint32 avId, uint32 treasureNum) broadcast;
  allTreasuresTaken() broadcast;
  hitBySuit(uint32 avId, int16 timestamp) clsend broadcast;
};

dclass DistributedTugOfWarGame : DistributedMinigame {
  reportPlayerReady(uint8 side) p2p clsend;
  changeButtons(uint8array buttons) broadcast;
  sendGoSignal(uint8array index) broadcast;
  sendStopSignal(uint32array winList, uint32array lossList, uint32array tieList) broadcast;
  sendGameType(uint8 index, uint8 index) broadcast;
  reportEndOfContest(uint8 index) p2p clsend;
  sendNewAvIdList(uint32array newAvIdList) p2p clsend;
  // these two are sent periodically with each player's power
  // so you can see how the remote toons are doing
  reportCurrentKeyRate(uint32 keyrate, int16 / 100) p2p clsend;
  sendCurrentPosition(uint32array avidlist, int16array index / 1000) broadcast;
  sendSuitPosition(int16 index / 1000) broadcast;
  remoteKeyRateUpdate(uint32 avId, uint32 keyrate) broadcast;
};

dclass DistributedCatchGame : DistributedMinigame {
  claimCatch(uint32 objNum, uint32 DropObjTypeId) p2p clsend;
  setObjectCaught(uint32 avId, uint32 objNum) broadcast;
  hitBySuit(uint32 avId, int16 timestamp) clsend broadcast;
  // In a multiplayer session, everyone reports in to the AI
  // server after all local drop objects have landed (or been caught).
  // When every client has reported in, the AI sends out an
  // 'everyone is done' message. At that point, the clients know
  // that any catch messages have already arrived and they can stop
  // listening for them.
  reportDone() p2p clsend;
  setEveryoneDone() broadcast;
};

//dclass DistributedTest {
//  setA(int16) broadcast ram required clsend;
//  setB(string) broadcast ram required clsend;
//  setC(int16) p2p clsend;
//};

dclass EstateManager : DistributedObject {
  // the AI tells the client which zone to use for his estate
  getEstateZone(uint32 avId, string name) airecv clsend;
  setEstateZone(uint32 avId, uint16 zoneId);
  setAvHouseId(uint32 avId, uint32array houseIds) broadcast;
  sendAvToPlayground(uint32 avId, uint8 status);
  exitEstate() p2p clsend;
  removeFriend(uint32 ownerId, uint32 avId) airecv clsend;
};

dclass DistributedEstate : DistributedObject {
  setEstateReady() broadcast;
  setClientReady() p2p clsend;

  setEstateType(uint8 index=0) required broadcast db;
  setClosestHouse(uint8 index) p2p clsend;
};


dclass DistributedHouse : DistributedObject {
  // if you add/delete any db fields, be sure to
  // make the according changes to the initFromServerResponse
  // function in DistributedHouseAI.py
  setHousePos(uint8 index=0) required broadcast db;
  setHouseType(uint8 index=3) required broadcast db;
  setGardenPos(uint8 index=0) required broadcast db;
  setAvatarId(uint32 avId=0) required broadcast db;
  setName(string name) required broadcast db;
  setColor(uint8 index=0) required broadcast db;
  setHouseColor(int16 r/10, int16 g/10, int16 b/10, int16 a/10) broadcast;
  sendHouseColor(int16 r/10,int16 g/10, int16 b/10, int16 a/10) broadcast;
  setHouseReady() broadcast ram;
};

// The interior of a toon house has its zone set
// dynamically, so we don't need to set it as a dc field
dclass DistributedHouseInterior : DistributedObject {
  setHouseId(uint32 houseId) required broadcast ram;
  setHouseIndex(uint8 index) required broadcast db;
  setWallColor(uint8 index) required broadcast db;
};

dclass DistributedCloset : DistributedObject {
  setOwnerId(uint32 ownerId) required broadcast ram;
  enterAvatar() p2p clsend;
  deleteItem(blob trashDNA, blob newDNA, uint8 which) p2p clsend;
  removeItem(blob trashDNA, uint8 which) p2p clsend;
  setDNA(blob dna, int8 finished, uint8 which) p2p clsend;
  setState(uint8 mode,
           uint32 avId, uint32 ownerId,
           string gender,
           uint8array topList, uint8array botList)
           broadcast ram;
  setMovie(uint8 mode, uint32 avId, int16 timestamp) broadcast ram;
  resetItemLists() broadcast ram;
};

dclass DistributedGarden : DistributedObject {
  sendNewProp(uint8, int16 x/10, int16 y/10, int16 z/10) broadcast;
};


dclass DeleteManager : DistributedObject {
  // Avatars ask the delete manager to set their inventory
  // to less than what it was. If they try to set it to more than
  // what it was, the request is ignored.
  setInventory(blob) p2p clsend;
};

// This is meant to be for debug only...
dclass MagicWordManager : DistributedObject {
  setMagicWord(string, uint32 avId, uint16 zoneId) p2p clsend;
  setMagicWordResponse(string) p2p;
  setWho(uint32array avIds) p2p clsend;
};

// For distributing news of the world
dclass NewsManager : DistributedObject {
  setPopulation(uint32) broadcast ram;
  setInvasionStatus(uint8 msgType, string cogType, uint32 numRemaining) broadcast;
};

dclass PurchaseManager : DistributedObject {
  // Info needed to create a Purchase Manager. Setting the countdown
  // actually displays the screen.
  setPlayerIds(uint32, uint32, uint32, uint32) required broadcast ram;
  setMinigamePoints(uint8, uint8, uint8, uint8) required broadcast ram;
  setPlayerMoney(uint8, uint8, uint8, uint8) required broadcast ram;
  setPlayerStates(uint8, uint8, uint8, uint8) required broadcast ram;
  setCountdown(int16 timestamp) required broadcast ram;

  // Input from the player
  requestExit() p2p clsend;
  requestPlayAgain() p2p clsend;
  setInventory(blob inventory, int16 money) p2p clsend;

  // Time is up
  setPurchaseExit() broadcast;
};

dclass SafeZoneManager : DistributedObject {
  enterSafeZone() p2p clsend;
  exitSafeZone() p2p clsend;
};

dclass TutorialManager : DistributedObject {
  // Players who want a tutorial send this.
  requestTutorial() p2p clsend;
  // Players who don't want a tutorial send this.
  rejectTutorial() p2p clsend;
  // This is how the manager puts a player into the tutorial
  enterTutorial(uint16 branchZone,
                uint16 streetZone,
                uint16 shopZone,
                uint16 hqZone) p2p;
  allDone() p2p clsend;
  toonArrived() p2p clsend;
};

//dclass DistributedTutorial : DistributedObject {
//  // This is how clients declare that they are done with a tutorial.
//  allDone() p2p clsend;
//};

dclass FriendManager : DistributedObject {
  // Messages from inviter client to AI
  // ****
  friendQuery(int32 inviteeId) p2p clsend;
  // ****
  cancelFriendQuery(int32 context) p2p clsend;

  // Messages from invitee client to AI
  // ****
  inviteeFriendConsidering(int8 yesNo, int32 context) p2p clsend;
  // ****
  inviteeFriendResponse(int8 yesNoMaybe, int32 context) p2p clsend;
  // ****
  inviteeAcknowledgeCancel(int32 context) p2p clsend;

  // Messages from AI to inviter client
  friendConsidering(int8 yesNo, int32 context) p2p;
  friendResponse(int8 yesNoMaybe, int32 context) p2p;

  // Messages from AI to invitee client
  inviteeFriendQuery(
          int32 inviterId,
          string inviterName,
          blob inviterDna,
          int32 context)
          p2p;
  inviteeCancelFriendQuery(int32 context) p2p;


  // Messages involving secrets.
  requestSecret() p2p clsend;
  requestSecretResponse(int8 result, string secret) p2p;

  submitSecret(string secret) p2p clsend;
  submitSecretResponse(int8 result, int32 avId) p2p;
};

dclass DistributedTreasure : DistributedObject {
  // Used to instantiate a treasure on the client
  setPosition(int16 x / 10, int16 y / 10, int16 z / 10) required broadcast ram;

  // Client to AI request for grabbing
  requestGrab() p2p clsend;

  // AI tells everyone that a treasure has been grabbed
  setGrab(uint32 avId) broadcast ram;

  // AI tells everyone that someone attempted to grab a treasure but
  // was rejected.
  setReject() broadcast;
};

// Safe zone treasure
dclass DistributedDDTreasure : DistributedTreasure {};
dclass DistributedDGTreasure : DistributedTreasure {};
dclass DistributedDLTreasure : DistributedTreasure {};
dclass DistributedTTTreasure : DistributedTreasure {};
dclass DistributedBRTreasure : DistributedTreasure {};
dclass DistributedMMTreasure : DistributedTreasure {};
// Estate treasure
dclass DistributedETreasure : DistributedTreasure {};

// Tag game treasure
dclass DistributedTagTreasure : DistributedTreasure {};

dclass DistributedTrophyMgr : DistributedObject {
  // An avatar requests his own trophy score.
  requestTrophyScore() p2p clsend;
};

dclass DistributedBuilding : DistributedObject {
  // We must know the block:
  setBlock(uint16 block, uint32 interiorZoneId) required broadcast ram;

  // Setup the building as a suit building
  // suitTrack is one of 'c', 'l', 'm', or 's'
  // difficulty is a value from 1 to 5
  // numFloors is a value from 1 to 5
  setSuitData(int8 suitTrack, int8 difficulty, int8 numFloors) required broadcast ram;

  // This is used to announce which toons will come running out of the
  // building when it is rescued. It is set just prior to setting
  // the state to "waitForVictors" and cleared just prior to setting the
  // state to "toon".
  setVictorList(uint32array={0, 0, 0, 0}) broadcast ram;

  // How the server tells the client what state to enter into
  // Used for states that want a timestamp
  setState(string state, int16 timestamp) broadcast ram;

  // How victors report that they are ready to march out of the elevator
  // for the Suit to Toon victory ceremony
  setVictorReady() p2p clsend;
};

dclass DistributedToonInterior : DistributedObject {
  // Pass the zoneId and the building block number separately, in
  // case they're ever not related.
  setZoneIdAndBlock(uint16 zoneId, uint16 blockNumber) required broadcast ram;

  // Setup the building as a toon building
  setToonData(blob toonData) required broadcast ram;

  // How the server tells the client what state to enter into
  setState(string state, int16 timestamp) required broadcast ram;
};

dclass DistributedSuitInterior : DistributedObject {
  setZoneId(uint16 zoneId) required broadcast ram;
  setExtZoneId(uint16 extZoneId) required broadcast ram;
  setDistBldgDoId(uint32) required broadcast ram;
  setNumFloors(int8 numFloors) required broadcast ram;

  setToons(uint32array toonsIds, uint16 hack) broadcast ram;
  setSuits(uint32array suitIds, uint32array reserveIds, uint16array values)
          broadcast ram;

  // How the server tells the client what state to enter into
  setState(string, int16 timestamp) required broadcast ram;

  // Messages from each client to indicate the client is ready to proceed.
  setAvatarJoined(string name, blob dnaNetString) p2p clsend;
  elevatorDone() p2p clsend;
  reserveJoinDone() p2p clsend;
};

dclass DistributedHQInterior : DistributedObject {
  // Pass the zoneId and the building block number separately, in
  // case they're ever not related.
  setZoneIdAndBlock(uint16 zoneId, uint16 blockNumber) required broadcast ram;
  setLeaderBoard(blob) required broadcast ram;
};

dclass DistributedGagshopInterior : DistributedObject {
  // Pass the zoneId and the building block number separately, in
  // case they're ever not related.
  setZoneIdAndBlock(uint16 zoneId, uint16 blockNumber) required broadcast ram;
};

dclass DistributedDoor : DistributedObject {
  // We must know the block:
  setZoneIdAndBlock(uint16 zoneId, uint16 blockNumber) required broadcast ram;

  // false: swings inward, true: the door swings outward.
  // bit 1 is the left door, bit 2 is the right door:
  setSwing(int8 flags) required broadcast ram;

  // The type of door loading that will need to take place
  setDoorType(uint8 doorType) required broadcast ram;

  // Some buildings have more than one door. Door indices generally
  // start at 0.
  setDoorIndex(uint8 doorIndex) required broadcast ram;

  // Answers the question: Where does this door go?
  setOtherZoneIdAndDoId(uint32 zoneId, uint32 doId) p2p;

  // This client wants to go though the door:
  requestEnter() p2p clsend;

  // The client can ask to leave the door:
  requestExit() p2p clsend;

  // Tell the toon they may not enter:
  rejectEnter(int8 reason) p2p;

  // Tell all nearby that a toon is entering the door queue:
  toonEnter(uint32 avatarId) broadcast;

  // Tell all nearby that a toon is exiting the door or door queue:
  toonExit(uint32 avatarId) broadcast;

  // Suits also enter doors.  But they don't exit them.
  suitEnter(uint32 avatarId) broadcast;

  // How the server tells the client what state to enter into
  // Used for states that want a timestamp
  setState(string state, int16 timestamp) required broadcast ram;
  // The "exit door" is also the "left door":
  setExitDoorState(string state, int16 timestamp) required broadcast ram;
};

dclass DistributedHouseDoor : DistributedDoor {
  // The doid of the house that owns this door
  setHouseId(uint32 houseId) required broadcast ram;
};


// Make sure the NPC is created after the interiors

// We don't inherit from DistributedToon, because that class has a
// bunch of stuff we don't care about, like experience and inventory.
dclass DistributedNPCToonBase : DistributedNode {
  setName(string) required broadcast ram db;
  setDNAString(blob) required broadcast ram db;

  // for a zone with N NPCs, there are N positions for the NPCs
  setPositionIndex(uint8) required broadcast ram;

  setAnimState(blob, int16 / 1000, int16 timestamp) broadcast ram clsend;

  // This is sent by the client to advance the page number in response
  // to setPageChat().
  setPageNumber(int16 paragraph, int8 pageNumber, int16 timestamp) broadcast ram clsend;

  // These let the server know when toons show up and leave
  avatarEnter() p2p clsend;
  // Free an avatar that is requesting interaction, but needs to be denied
  freeAvatar() p2p;
};

dclass DistributedNPCToon : DistributedNPCToonBase {
  // Quest movie
  // Not all of the fields are used in every mode,
  //   they will be 0 if they are not used
  setMovie(uint8 mode, uint32 npcId, uint32 avId, uint16array quests, int16 timestamp) broadcast ram;
  setMovieDone() p2p clsend;
  // Tell the server which quest we choose on the multiple choice menu
  chooseQuest(uint16 questId) p2p clsend;
  // Tell the server which track we choose on the multiple choice menu
  chooseTrack(int8 trackId) p2p clsend;
};

dclass DistributedNPCClerk : DistributedNPCToonBase {
  setMovie(uint8 mode, uint32 npcId, uint32 avId, int16 timestamp) broadcast ram;
  setInventory(blob inventory, int16 money) p2p clsend;
};

dclass DistributedNPCTailor : DistributedNPCToonBase {
  setMovie(uint8 mode, uint32 npcId, uint32 avId, int16 timestamp) broadcast ram;
  setDNA(blob dna, int8 finished, uint8 which) p2p clsend;
};

dclass DistributedNPCBlocker : DistributedNPCToonBase {
  setMovie(uint8 mode, uint32 npcId, uint32 avId, int16 timestamp) broadcast ram;
};

dclass DistributedAnimatedProp : DistributedObject {
  // DistributedAnimatedProp is for things that the toon can
  // interact with, that other toons can see.  For example:
  // the knock, knock joke doors on the Toon side buildings.
  // Note: It is because the joke doors don't actually allow
  // the toon to go through them, that they are AnimatedProps,
  // instead of Doors.

  // We must know the prop ID:
  setPropId(uint16 propId) required broadcast ram;

  // This client wants to interact with the prop:
  requestInteract() p2p clsend;

  // Tell the toon they may not interact with the prop:
  rejectInteract() p2p;

  // This client wants to stop interacting with the prop:
  requestExit() p2p clsend;

  // Tell all nearby that a toon is interacting with the prop:
  setAvatarInteract(uint32 avatarId) required broadcast ram;

  // Toon avatarId is no longer interacting with the prop:
  avatarExit(uint32 avatarId) broadcast;

  // How the server tells the client what state to enter into
  // Used for states that want a timestamp
  setState(string state, int16 timestamp) required broadcast ram;
};

dclass DistributedKnockKnockDoor : DistributedAnimatedProp {
}

dclass DistributedElevator : DistributedObject {
  // How the server tells the client what state to enter into
  setState(string, int16 timestamp) broadcast ram;
  // How the server tells the client to fill the slots
  fillSlot0(uint32 avId,
            int16 x/10, int16 y/10, int16 z/10,   // initial xyz
            int16 h/10, int16 p/10, int16 r/10,   // initial hpr
            int16 timestamp) broadcast ram;       // time of boarding
  fillSlot1(uint32 avId,
            int16 x/10, int16 y/10, int16 z/10,   // initial xyz
            int16 h/10, int16 p/10, int16 r/10,   // initial hpr
            int16 timestamp) broadcast ram;       // time of boarding
  fillSlot2(uint32 avId,
            int16 x/10, int16 y/10, int16 z/10,   // initial xyz
            int16 h/10, int16 p/10, int16 r/10,   // initial hpr
            int16 timestamp) broadcast ram;       // time of boarding
  fillSlot3(uint32 avId,
            int16 x/10, int16 y/10, int16 z/10,   // initial xyz
            int16 h/10, int16 p/10, int16 r/10,   // initial hpr
            int16 timestamp) broadcast ram;       // time of boarding

  // How the server tells the client to empty the slots
  emptySlot0(uint32 avId, int8 bailFlag, int16 timestamp) broadcast ram;
  emptySlot1(uint32 avId, int8 bailFlag, int16 timestamp) broadcast ram;
  emptySlot2(uint32 avId, int8 bailFlag, int16 timestamp) broadcast ram;
  emptySlot3(uint32 avId, int8 bailFlag, int16 timestamp) broadcast ram;

  // How the client requests permission to board
  requestBoard(int16 x/10, int16 y/10, int16 z/10,   // initial xyz
               int16 h/10, int16 p/10, int16 r/10    // initial hpr
               ) p2p clsend;

  // How the server rejects permission to board
  rejectBoard(uint32 avId) p2p;

  // How the client request permission to exit
  requestExit() p2p clsend;

};

dclass DistributedElevatorExt : DistributedElevator {
  // We must know the doId of the building we are associated with.
  // The building knows the zone it is in, and the zone that is
  // inside it.
  setBldgDoId(uint32 doId) required broadcast ram;
  // This is how the AI communicates the floor number that should
  // be displayed on the outside of the elevator.
  setFloor(int8 floor) broadcast ram;
};

dclass DistributedElevatorInt : DistributedElevator {
  // We must know the doId of the building interior we are associated
  // with, so we can find the elevator model on the client.
  setSuitInteriorDoId(uint32 doId) required broadcast ram;
  // How the client lets the server know that he intends to
  // exit the building.
  requestBuildingExit() p2p clsend;
  // How the server lets the client know he has just
  // been kicked out of the building.
  forcedExit(uint32 avId) p2p;
};

dclass DistributedTutorialInterior : DistributedObject {
  // Pass the zoneId and the building block number separately, in
  // case they're ever not related.
  setZoneIdAndBlock(uint16 zoneId, uint16 blockNumber) required broadcast ram;
  setTutorialNpcId(uint32 npcId) required broadcast ram;
};

dclass DistributedBankMgr : DistributedObject {
  // A positive amount indicates a deposit to the bank
  transferMoney(int16 amount) p2p clsend;
}

dclass DistributedBank : DistributedObject {
  // These let the server know when toons show up and leave
  avatarEnter() p2p clsend;
  // Free an avatar that is requesting interaction, but needs to be denied
  freeAvatar() p2p;
  // Maintain distributed state on the bank
  setMovie(uint8 mode, uint32 avId, int16 timestamp) broadcast ram;
  // A positive amount indicates a deposit to the bank
  transferMoney(int16 amount) p2p clsend;
}

dclass DistributedTester : DistributedObject {
  setState(string state, int16 timestamp) required broadcast ram;
  setMovie(
           //   flag indicating an empty movie
           //   array of toon doIds
           //   array of suit doIds
           int8 active, uint32array toons, uint32array suits,

           //   index of attacking toon
           //   attack track
           //   attack level
           //   index of the target (or doId if it's an SOS)
           //   array of damages
           //   accuracy bonus for the attack
           //   damage bonus for the attack
           //   array of knockback bonuses
           //   bit-field indicating indices of suits that have died from this attack
           int8 id0, int8 tr0, int8 le0, uint32 tg0, int16array hp0,
           int16 ac0, int16 hpb0, int16array kbb0, int8 died0,

           int8 id1, int8 tr1, int8 le1, uint32 tg1, int16array hp1,
           int16 ac1, int16 hpb1, int16array kbb1, int8 died1,

           int8 id2, int8 tr2, int8 le2, uint32 tg2, int16array hp2,
           int16 ac2, int16 hpb2, int16array kbb2, int8 died2,

           int8 id3, int8 tr3, int8 le3, uint32 tg3, int16array hp3,
           int16 ac3, int16 hpb3, int16array kbb3, int8 died3,

           //   index of the attacking suit
           //   id of the suit's attack
           //   index of the target of the attack
           //   array of damages
           //   bit-field indicating indices of toons that have died from this attack
           //   flag indicating if this suit attacks before the toons this round
           int8 sid0, int8 at0, int8 stg0, int16array dm0, int8 sd0,
           int8 db0, int8 st0,

           int8 sid1, int8 at1, int8 stg1, int16array dm1, int8 sd1,
           int8 db1, int8 st1,

           int8 sid2, int8 at2, int8 stg2, int16array dm2, int8 sd2,
           int8 db2, int8 st2,

           int8 sid3, int8 at3, int8 stg3, int16array dm3, int8 sd3,
           int8 db3, int8 st3
           ) required broadcast ram;
   }

dclass DistributedFireworkShow : DistributedObject {
   // Start a firework show
   // Note: there is no stop show, we just delete the object
   startShow(uint8 showStyle, int16 timestamp) broadcast ram;

   // Request to shoot a firework at my position with a style and color of
   // my choosing. The AI will either shoot this firework or not, deducting
   // the price of it as well.
   requestFirework(int16/10 x, int16/10 y, int16/100 z, uint8 style, uint8 color) p2p clsend;

   // Ususally comes as the result of a requestFirework
   shootFirework(int16/10 x, int16/10 y, int16/100 z, uint8 style, uint8 color) broadcast;
};
